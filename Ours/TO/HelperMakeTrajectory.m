classdef HelperMakeTrajectory < matlab.System    
    % Forked from MathWorks, Inc.

    properties(Access = private)
        
        % RefPathFrenet holds the instance of referencePathFrenet.
        % The RefPathFrenet holds the instance of referencePathFrenet. This
        % is used to instantiate trajectoryGeneratorFrenet.
        RefPathFrenet;
        
        % CurrentTrajectory holds the generated trajectories in current step.
        % CurrentTrajectory variable is a structure containing trajectory
        % points, and corresponding time samples.
        CurrentTrajectory;
        
        % NumTrajectories holds the number of trajectories generated by the
        % trajectoryGeneratorFrenet.
        % NumTrajectories holds the value of number of trajectories
        % generated by the trajectoryGeneratorFrenet at every replan
        % cycle.
        NumTrajectories;
        
        % RefPathPoints holds the waypoints for the global plan.
        % The RefPathPoints holds the waypoints of the global plan. The
        % default value is [0 0;600 0]
        RefPathPoints;
    end
    
    %----------------------------------------------------------------------
    % Main algorithm
    %----------------------------------------------------------------------
    
    methods
        function obj = HelperMakeTrajectory(varargin)
            % Support name-value pair arguments when constructing object
            setProperties(obj, nargin,varargin{:})
            coder.varsize('referencePathPoints');
            referencePathPoints = [0 0; 600, 0];
            obj.RefPathPoints = referencePathPoints;
        end
    end
    
    methods(Access = protected)
        %------------------------------------------------------------------
        function setupImpl(obj)
            % setupImpl function performs the one time calculations and
            % Initializations.
            % The setupImpl function is used to initialize values or
            % the object to RefPathFrenet and PreviousTrajectory.
            
            % Initializing the reference path Frenet with a default
            % reference path.
            obj.RefPathFrenet = referencePathFrenet(obj.RefPathPoints);
            
            % Creating a structure for storing the trajectories and
            % the time.
            obj.CurrentTrajectory  = HelperLCPlannerDefaultData.GlobalTrajectories().GlobalTrajectory;
            obj.NumTrajectories    = 1;
        end
        %------------------------------------------------------------------
        function GlobalTrajectories = stepImpl(obj, ...  
                                               Optimizer, ...
                                               EgoState, ...
                                               params, ... 
                                               MapInfo, ...
                                               Planresult, ...
                                               replanningSignal, ...
                                               resamplingSignal)
            % stepImpl executes the main algorithm for 
            % generating the trajectories at every replan cycle.

            % Arguments: 
            %   1. Optimizer         : Optimal Control Points for Piece-Wise Bezier Curve
            %   2. EgoState          : Ego의 Global Frenet States [s, ds, dds, l, dl, ddl]
            %   3. MIOState          : MIO의 Global Frenet States [s, ds, dds, l, dl, ddl]
            %   4. Params            : Planner Parameters
            %   5. MapInfo           : Map Information
            %   6. ReplanningSignal  : Replanning Signal by Duration Timeout
            %   7. ResamplingSignal  : Replanning Signal by Decision Change
            persistent prev_GlobalTrajectories prev_mio
            N = params.num_piece;
            m = params.degree;
            use_resample = params.Useresample;
            timeHorizon = params.TimeHorizon;
            timestep    = params.TimeResolution;
            planningResolution = params.PlanningResolution;
            Ps = Optimizer.Optimal_S;
            Pd = Optimizer.Optimal_D;
            MIOState = Optimizer.Target_MIO_State;
            
            GlobalTrajectories = HelperLCPlannerDefaultData.GlobalTrajectories;
            if replanningSignal
                % Trajectory Planinng by Duration Timeout
                if ~isequal(obj.RefPathPoints, MapInfo.GlobalPlanPoints(1:MapInfo.NumGlobalPlanPoints,:))
                    obj.RefPathPoints = MapInfo.GlobalPlanPoints(1:MapInfo.NumGlobalPlanPoints,:);
                    obj.RefPathFrenet.Waypoints = obj.RefPathPoints;
                end
                % Generate trajectories
                obj.CurrentTrajectory = updateTrajectories(obj, ...
                                                        EgoState, ...
                                                        MapInfo, ...
                                                        Ps, Pd, ...
                                                        timeHorizon, timestep, planningResolution, ...
                                                        N, m);
                % Target Trajectory 하나만 존재
                GlobalTrajectories.NumTrajectories = 1;
                GlobalTrajectories.IsNew = true;
                GlobalTrajectories.OptimalTrajectoryIndex = 1;
                GlobalTrajectories.GlobalTrajectory = obj.CurrentTrajectory;
                prev_GlobalTrajectories = GlobalTrajectories;


            elseif ~replanningSignal && resamplingSignal
                if Planresult == 1
                    % Trajectory Planning by Decision Change
                    obj.CurrentTrajectory = updateTrajectories(obj, ...
                                                            EgoState, ...
                                                            MapInfo, ...
                                                            Ps, Pd, ...
                                                            timeHorizon, timestep, planningResolution, ...
                                                            N, m);
                    if use_resample 
                        % Safety와 Consistency 간의 Balance 판단
                        [TargetTraj, OtherTraj, Isresample] = selectFinalTrajectory(obj, ...
                                                                                    prev_GlobalTrajectories, ...
                                                                                    EgoState, ...
                                                                                    MIOState, ...
                                                                                    prev_mio, ...
                                                                                    MapInfo, ...
                                                                                    params);
                        GlobalTrajectories.NumTrajectories = 2;
                        if Isresample
                            % resample 경로가 선택됐을 때만 New로 갱신
                            GlobalTrajectories.IsNew = true;
                            GlobalTrajectories.Isresample = true;
                        else
                            % 기존 경로가 선택됐을때는 New 갱신 X
                            GlobalTrajectories.IsNew = false;
                            GlobalTrajectories.Isresample = false;
                        end
                        GlobalTrajectories.OptimalTrajectoryIndex = 1;
                        GlobalTrajectories.GlobalTrajectory(1) = TargetTraj;
                        GlobalTrajectories.GlobalTrajectory(2) = OtherTraj;
                        GlobalTrajectories.GlobalTrajectory(2).IsEvaluated = false;
                        prev_GlobalTrajectories = GlobalTrajectories;
                    else
                        % Target Trajectory 하나만 존재
                        GlobalTrajectories.NumTrajectories = 1;
                        GlobalTrajectories.IsNew = true;
                        GlobalTrajectories.OptimalTrajectoryIndex = 1;
                        GlobalTrajectories.GlobalTrajectory = obj.CurrentTrajectory;
                        prev_GlobalTrajectories = GlobalTrajectories;
                    end
                else
                    GlobalTrajectories = prev_GlobalTrajectories;
                    GlobalTrajectories.IsNew = false;
                end

            else
                GlobalTrajectories = prev_GlobalTrajectories;
                GlobalTrajectories.IsNew = false;
            end
            prev_mio = MIOState;
        end

        function [TargetTraj, OtherTraj, Isresample] = selectFinalTrajectory(objLocal, ...
                                                                             prev_Traj, ...
                                                                             EgoState, ...
                                                                             MIOState, ...
                                                                             Prev_MIOState, ...
                                                                             MapInfo, ...
                                                                             params)
            % Argument :
            %   prev_Traj : GlobalTrajectories Object
            %   CurrentTrajectory : Array of GlobalTrajectory Object
            % Output : 
            %   TargetTraj : GlobalTrajectory Object
            %   OtherTraj : GlobalTrajectory Object
            NumTrajPoints = prev_Traj.GlobalTrajectory(1).NumTrajPoints;

            ego_s  = EgoState(1);
            ego_d  = EgoState(4);
            
            cur_traj_f   = global2frenet(objLocal.RefPathFrenet, objLocal.CurrentTrajectory(1).Trajectory);
            prev_traj_f  = global2frenet(objLocal.RefPathFrenet, prev_Traj.GlobalTrajectory(1).Trajectory); 
            
            [~, i] = min(abs(prev_traj_f(:, 1)-ego_s)); % 현재 Ego와 가장 가까운 Point의 Index (추종 중인 궤적의 진행도 계산 위함)
            start_id = i;

            % Safety : TTC
            % Current는 TTC 계산 시, 현재 MIO로 잡힌 차량을 기준으로 시간 T이후의 TTC 검사 (0 -> 4)
            cur_safe = calculateTTCSummation(objLocal, EgoState, MIOState, cur_traj_f, 1, NumTrajPoints, params);
            % Prev는 TTC 계산 시, 이전 MIO의 위치 (t_k -> 4)
            prev_safe = calculateTTCSummation(objLocal, EgoState, Prev_MIOState, prev_traj_f, start_id, NumTrajPoints, params);

            % Consistency Penalty : Tracking Progress Weight (TPW) * Lateral Drift Ratio (LDR)
            TPW = start_id / NumTrajPoints; % [0, 1]
            LDR = max(0, min(1, abs(cur_traj_f(end, 4) - ego_d) / (abs(prev_traj_f(end, 4) - ego_d) + 1e-6))); % [0, 1]
            prev_cons = 0;
            cur_cons = TPW * LDR;
            
            % Penalty 개념 -> 클수록 안좋음
            cur_sum = cur_cons + cur_safe;
            prev_sum = prev_cons + prev_safe;
            fprintf("================= Decision Consistency Evaluation ================= \n");
            fprintf("Existing Traj : Safe : %.2f | Consistency : %.2f | Total : %.2f\n", prev_safe, prev_cons, prev_sum);
            fprintf("New Traj : Safe : %.2f | Consistency : %.2f | Total : %.2f\n", cur_safe, cur_cons, cur_sum);
            
            if (cur_sum > prev_sum)
                TargetTraj = prev_Traj.GlobalTrajectory(1);
                OtherTraj = objLocal.CurrentTrajectory(1);
                Isresample = false;
            else
                TargetTraj = objLocal.CurrentTrajectory(1);
                OtherTraj = prev_Traj.GlobalTrajectory(1);
                Isresample = true;
            end
        end

        function ttc_normalized = calculateTTCSummation(obj, EgoState, MIOState, Traj, Startid, NumValidPoints, params)
            
            step = params.TimeResolution;
            max_ttc = params.MaxTTC;
            min_ttc = params.MinTTC;
            maxFront = params.MaxFront;
            maxRear = params.MaxRear;
            % Trajectory의 종방향 추출
            Traj_s = Traj(:, 1);
            Traj_vs = Traj(:, 2);
            
            % Ego 종방향 정보 추출
            ego_s  = EgoState(1);
            ego_vs = EgoState(2);
            ego_sT = Traj_s(end);
            ego_vT = Traj_vs(end);
            
            % MIO의 시점 T에서의 종방향 추출
            if all(MIOState == 0)
                ttc_normalized = 0.0;
                return; 
            end
            delta_t = step * (NumValidPoints - Startid);
            mio_s = MIOState(1);
            mio_vs = MIOState(2);
            mio_sT = mio_s + mio_vs * delta_t;
            mio_vT = mio_vs;

            if ego_s > mio_s
                % MIO가 후방에 위치
                if ego_sT < mio_sT
                    % 시간이 모두 흐른 뒤, 역전 (=충돌)
                    ttc_normalized = 1.0;
                else
                    % 시간이 모두 흐른 뒤, 역전 X
                    if ego_vT > mio_vs
                        % MIO 후방, Ego가 더 빠르면 TTC 정의 X
                        ttc_normalized = 0.0;
                    else
                        % MIO 후방, Ego가 더 느리면 TTC 정의 O
                        ttc = max(min_ttc, min(max_ttc, (ego_sT - mio_sT - maxRear) / (mio_vT - ego_vT)));
                        ttc_normalized = 1 - (ttc-min_ttc) / (max_ttc-min_ttc);
                    end
                end
            else
                % MIO가 전방에 위치
                if ego_sT > mio_sT
                    % 시간이 모두 흐른 뒤, 역전 (=충돌)
                    ttc_normalized = 1.0;
                else
                    % 시간이 모두 흐른 뒤, 역전 X
                    if ego_vT < mio_vs
                        % MIO 전방, Ego가 더 느리면 TTC 정의 X
                        ttc_normalized = 0.0;
                    else
                        % MIO 전방, Ego가 더 빠르면 TTC 정의 O
                        ttc = max(min_ttc, min(max_ttc, (mio_sT - ego_sT - maxFront) / (ego_vT - mio_vT)));
                        ttc_normalized = 1 - (ttc-min_ttc) / (max_ttc-min_ttc);
                    end
                end
            end
        end

        function PrevTraj = updateTrajectories(objLocal, ...
                                               EgoState, ...
                                               MapInfo, ...
                                               Ps, Pd, ...
                                               tHorizon, dt, planning_dt, ...
                                               N, m)
            % 외부 변수 참조 없이 함수 입력값/objLocal로만 처리
            newTraj = HelperLCPlannerDefaultData.GlobalTrajectories().GlobalTrajectory;
            % 4 / (8) = 0.5, 0.5 / 0.1 = 6개
            numTrajPoints = size(newTraj(1).Times, 1);
            num_samples = 1 + planning_dt/dt; 

            % 전체 궤적을 저장할 배열 초기화
            s_traj = zeros(numTrajPoints, 1);
            d_traj = zeros(numTrajPoints, 1);
            t_traj = zeros(numTrajPoints, 1);
            vs_traj = zeros(numTrajPoints, 1);
            vd_traj = zeros(numTrajPoints, 1);
            as_traj = zeros(numTrajPoints, 1);
            ad_traj = zeros(numTrajPoints, 1);
            
            current_idx = 1;
            for piece_idx = 1:N
                % 현재 구간 제어점 [0, 1] 정규화 공간
                Ps_piece = Ps(piece_idx, :);
                Pd_piece = Pd(piece_idx, :);
                % 구간 내 시간 파라미터 [0, 1]
                u = linspace(0, 1, num_samples); 
                if piece_idx > 1
                    % 첫번째 구간만 6개 전부 사용..
                    % 6 + 5*(7) = 41개 딱 맞아 떨어짐
                    u = u(2:end); 
                end
                Nu = numel(u);
                
                % 현재 구간의 실제 시간
                t_start = (piece_idx - 1) * planning_dt;
                t_end = piece_idx * planning_dt;
                t_piece = t_start + u * planning_dt;

                % 베지어 곡선 및 도함수 계산
                [s_piece, d_piece, ...
                 vs_piece, vd_piece, ...
                 as_piece, ad_piece] = objLocal.evaluate_bezier_curve(Ps_piece, Pd_piece, planning_dt, m, u);

                % 전체 궤적에 추가
                s_traj(current_idx:current_idx+Nu-1) = s_piece;
                d_traj(current_idx:current_idx+Nu-1) = d_piece;
                vs_traj(current_idx:current_idx+Nu-1) = vs_piece;
                vd_traj(current_idx:current_idx+Nu-1) = vd_piece;
                as_traj(current_idx:current_idx+Nu-1) = as_piece;
                ad_traj(current_idx:current_idx+Nu-1) = ad_piece;
                t_traj(current_idx:current_idx+Nu-1) = t_piece;
                current_idx = current_idx + Nu;
            end

            frenetTraj_e = [s_traj, vs_traj, as_traj, ...
                            d_traj, vd_traj, ad_traj];
            frenetTraj_w = frenetTraj_e;
            frenetTraj_w(:, 1) = frenetTraj_w(:, 1) + EgoState(1);
            frenetTraj_w(:, 4) = frenetTraj_w(:, 4) + EgoState(4);

            globalTraj = frenet2global(objLocal.RefPathFrenet, frenetTraj_w, ...
                                       [vd_traj, ad_traj, false*ones(length(t_traj),1)]);


            % Trajectory 정보 업데이트
            newTraj(1).Times(1:numTrajPoints)           = t_traj;
            newTraj(1).Trajectory(1:numTrajPoints,:)    = globalTraj;
            newTraj(1).NumTrajPoints                    = numTrajPoints;
            newTraj(1).DurationTime                     = tHorizon;
            newTraj(1).IsValid      = true;
            newTraj(1).IsEvaluated  = true;
            newTraj(1).TargetLane = helperDetectLaneNumber(MapInfo, frenetTraj_w(end, 4));
            PrevTraj = newTraj;
        end

        function [s, d, vs, vd, as, ad] = evaluate_bezier_curve(obj, Ps, Pd, dt, m, u)
            
            % --- 1. 위치 계산 ---
            % 위치 곡선의 제어점은 Ps, Pd 그대로 사용
            B = obj.compute_bernstein_basis(m, u); % 위치 기저 함수만 필요
            s = dt * Ps * B;
            d = dt * Pd * B;

            % --- 2. 속도 계산 (Hodograph) ---
            % 속도 곡선(m-1차)의 제어점을 먼저 계산
            Ps_dot = m * diff(Ps); 
            Pd_dot = m * diff(Pd);
            % 속도 곡선에 대한 기저 함수 계산
            B_vel = obj.compute_bernstein_basis(m - 1, u);
            % 속도 계산 및 시간 스케일링
            vs = (Ps_dot * B_vel);
            vd = (Pd_dot * B_vel);

            % --- 3. 가속도 계산 (Hodograph) ---
            % 가속도 곡선(m-2차)의 제어점을 계산
            Ps_ddot = m * (m - 1) * diff(Ps, 2); % 2차 차분
            Pd_ddot = m * (m - 1) * diff(Pd, 2);
            % 가속도 곡선에 대한 기저 함수 계산
            B_acc = obj.compute_bernstein_basis(m - 2, u);
            % 가속도 계산 및 시간 스케일링
            as = (Ps_ddot * B_acc) / (dt);
            ad = (Pd_ddot * B_acc) / (dt); 
        end


        function B = compute_bernstein_basis(obj, degree, u)
            n_samples = length(u);
            n_basis = degree + 1;
            B = zeros(n_basis, n_samples);

            for i = 0:degree
                binomial_coeff = nchoosek(degree, i);
                B(i+1, :) = binomial_coeff * (u.^i) .* ((1-u).^(degree-i));
            end
        end
    end
    
    %----------------------------------------------------------------------
    % Common methods
    %----------------------------------------------------------------------
    methods(Access = protected)
        %------------------------------------------------------------------
        function s = saveObjectImpl(obj)
            % save object
            s = saveObjectImpl@matlab.System(obj);
        end
        
        %------------------------------------------------------------------
        function loadObjectImpl(obj,s,wasLocked)
            % load object
            loadObjectImpl@matlab.System(obj,s,wasLocked);
        end
    end
    
    %----------------------------------------------------------------------
    % Simulink-only methods
    %----------------------------------------------------------------------
    methods(Access = protected)
        %------------------------------------------------------------------
        function GlobalTraj=getOutputSizeImpl(~)
            % Return size for each output port
            GlobalTraj=1;
        end
        
        %------------------------------------------------------------------
        function Trajectory= getOutputDataTypeImpl(~)
            % Return data type for each output port
            Trajectory="BusGlobalTrajectories";
            
        end
        
        %------------------------------------------------------------------
        function Trajectory= isOutputComplexImpl(~)
            % Return true for each output port with complex data
            Trajectory= false;
    
        end
        
        %------------------------------------------------------------------
        function Trajectory= isOutputFixedSizeImpl(~)
            % Return true for each output port with fixed size
            Trajectory= true;
        end        
    end    
end