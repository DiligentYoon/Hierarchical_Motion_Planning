classdef HelperMotionPrediction_RMC<matlab.System
    %HelperMotionPrediction System Object computes future states
    %of the MIOS based on current states using constant velocity model.
    %
    % HelperMotionPrediction System Object uses the current MIO
    % Position to predict the future trajectories of MIO by assuming them
    % to be moving with a constant velocity during the planning time and
    % computing the states accordingly
    %
    % Step function Syntax:function FutureTrajectory = stepImpl(obj,Params,
    % LaneInfo, MIOs). It returns the predicted trajectories of the MIOs,
    % FutureTrajectory respectively based on the information of the planner
    % parameters, Params, global plan points coming from, LaneInfo, and
    % MIOs Frenet state information, MIOs.
    %
    % NOTE: The name of this System Object and it's functionality may
    % change without notice in a future release, or the System Object
    % itself may be removed.
    %
    
    % Copyright 2020-2022 The MathWorks, Inc.
    
    %----------------------------------------------------------------------
    %Private Variables
    properties(Access = private)
        
        %RefPathFrenet holds the object of  referencePathFrenet for a
        %particular Reference Path.
        % RefPathFrenet holds the instance of referencePathFrenet. The
        % RefPathFrenet object is used for transforming the Frenet
        % trajectories to global trajectories.
        RefPathFrenet;
                
        %RefPathPoints is used to store the waypoints for the
        %reference path generated by RefPathFrenet.
        RefPathPoints;

        %PredictedTrajectoryInitStruct defines the predicted trajectory
        % structure that was defined by the Bus object in base workspace.
        % Default = struct
        PredictedTrajectoryInitStruct = HelperLCPlannerDefaultData.PredictedTrajectories;

        % Time Horizon for which the planning has to be done.
        % Default value = 3
        TimeHorizons = 4;
        
        % TimeResolution defines the time interval between.
        % Default = 0.1
        PlanningResolution = 0.5;
        
        % Total Number of Target vehicles.
        % Default = 50
        NumTargets = 30;
    end
    
    %----------------------------------------------------------------------
    % Main algorithm
    %----------------------------------------------------------------------
    methods
        function obj = HelperMotionPrediction_RMC(varargin)
            % Support name-value pair arguments when constructing object
            setProperties(obj, nargin,varargin{:})
            coder.varsize('referencePathPoints');
            
            % Initialize RefPathPoints.
            referencePathPoints = [0 0; 600, 0];
            obj.RefPathPoints = referencePathPoints;
        end
    end
    
    methods(Access = protected)
        %------------------------------------------------------------------
        function setupImpl(obj)
            % setupImpl function performs the one time calculations and
            % Initializations
            % The setupImpl function is used to initialize values or
            % the object to RefPathFrent and compute the maximum
            % of the timeHorizons (if given a range)
            
            % Construct and assign referencePathFrenet object with a
            % default initial path to RefPathFrenet
            obj.RefPathFrenet = referencePathFrenet(obj.RefPathPoints);           
        end
        
        %------------------------------------------------------------------
        function [FutureGlobalTrajectories,...
                  FutureGlobalCoordTrajectories]   = stepImpl(obj, MIOs_Relative, MIOs_Global, MapInfo, Params)
            % stepImpl executes the main algorithm and generates the MIO
            % Positions and the future trajectories of the MIOs using a
            % constant velocity model.
            obj.TimeHorizons = Params.TimeHorizon;
            obj.PlanningResolution = Params.PlanningResolution;
            
            % Check if there is any change in the waypoints and update the
            % RefPathFrenet object
            refPath = MapInfo.GlobalPlanPoints(1:MapInfo.NumGlobalPlanPoints,:);
            if ~isequal(obj.RefPathFrenet.Waypoints,refPath)
                obj.RefPathPoints = MapInfo.GlobalPlanPoints(1:MapInfo.NumGlobalPlanPoints,:);
                obj.RefPathFrenet.Waypoints = obj.RefPathPoints;
            end
            
            % Initialize FutureTrajectory structure to hold the future
            % trajectories of MIOs
            % FutureRelativeTrajectories = obj.PredictedTrajectoryInitStruct;
            FutureGlobalTrajectories = obj.PredictedTrajectoryInitStruct;
            FutureGlobalCoordTrajectories = obj.PredictedTrajectoryInitStruct;
            
            % Calculating the number of states needed to be predicted
            maxNumStates = (max(obj.TimeHorizons))/(obj.PlanningResolution)+1;
            
            % Extract MIOs information from input
            numMIOs = MIOs_Relative.NumMIOs;
            targetIDS = uint8(zeros(obj.NumTargets, 1));
            targetIDS(1:numMIOs,1) = MIOs_Relative.TargetIds(1, 1:numMIOs);
            numTrajs = 0;
            
            %% Calculate the future motion of MIOs using constant velocity model
            for j = 1:numMIOs
                % Validate the MIO information
                if all(~isnan((MIOs_Relative.MIOStates(j,:))))
                    numTrajs = numTrajs + 1;
                    
                    % Get Initial state of the MIO (Relative)
                    initFrenetState_Relative = MIOs_Relative.MIOStates(j,:); 
                    initFrenetState_Global   = MIOs_Global.MIOStates(j, :);
                    times = Params.TimeResolution*(0:maxNumStates-1);
                    
                    % target trajectory in relative & global Frenet frame
                    % frenetStates_Relative = repmat(initFrenetState_Relative, maxNumStates, 1);
                    % frenetStates_Relative(:,1) = frenetStates_Relative(:,1) + times(:)*initFrenetState_Relative(2); % initFrenetState(2) = ds/dt
                    % frenetStates_Relative(:,4) = frenetStates_Relative(:,4) + times(:)*initFrenetState_Relative(5);
                    frenetStates_Global = repmat(initFrenetState_Global, maxNumStates, 1);
                    frenetStates_Global(:, 1) = frenetStates_Global(:,1) + times(:)*initFrenetState_Global(2); % initFrenetState(2) = ds/dt
                    frenetStates_Global(:, 4) = frenetStates_Global(:,4) + times(:)*initFrenetState_Global(5);
                    
                    % predict target trajectory in relative & global Frenet frame
                    % FutureRelativeTrajectories.Trajectories(numTrajs).Trajectory(1:maxNumStates,:) = frenetStates_Relative(1:maxNumStates,:);
                    % FutureRelativeTrajectories.Trajectories(numTrajs).NumPts = uint16(maxNumStates);
                    % FutureRelativeTrajectories.Trajectories(numTrajs).TargetID = uint8(MIOs_Relative.TargetIds(j));

                    FutureGlobalTrajectories.Trajectories(numTrajs).Trajectory(1:maxNumStates,:) = frenetStates_Global(1:maxNumStates,:);
                    FutureGlobalTrajectories.Trajectories(numTrajs).NumPts = uint16(maxNumStates);
                    FutureGlobalTrajectories.Trajectories(numTrajs).TargetID = uint8(MIOs_Global.TargetIds(j));

                    FutureGlobalCoordTrajectories.Trajectories(numTrajs).Trajectory(1:maxNumStates,:) = frenet2global(obj.RefPathFrenet,...
                                                                                                                      frenetStates_Global(1:maxNumStates,:),...
                                                                                                                      [frenetStates_Global(1:maxNumStates,5), frenetStates_Global(1:maxNumStates,6), false*ones(maxNumStates, 1)]);
                    FutureGlobalCoordTrajectories.Trajectories(numTrajs).NumPts = uint16(maxNumStates);
                    FutureGlobalCoordTrajectories.Trajectories(numTrajs).TargetID = uint8(MIOs_Relative.TargetIds(j));
                end
            end
            % FutureRelativeTrajectories.NumTrajs = uint8(numTrajs);
            FutureGlobalTrajectories.NumTrajs = uint8(numTrajs);
            FutureGlobalCoordTrajectories.NumTrajs = uint8(numTrajs);
            for i=1:obj.NumTargets
                % FutureRelativeTrajectories.TargetIDs(i,1) = uint8(targetIDS(i,1));
                FutureGlobalTrajectories.TargetIDs(i,1) = uint8(targetIDS(i,1));
                FutureGlobalCoordTrajectories.TargetIDs(i,1) = uint8(targetIDS(i,1));
            end
        end
    end
    
    %----------------------------------------------------------------------
    % Common methods
    %----------------------------------------------------------------------
    methods(Access = protected)
        %------------------------------------------------------------------
        function s = saveObjectImpl(obj)
            % save object
            s = saveObjectImpl@matlab.System(obj);
        end
        
        %------------------------------------------------------------------
        function loadObjectImpl(obj,s,wasLocked)
            % load object
            loadObjectImpl@matlab.System(obj,s,wasLocked);
        end
    end
    
    %----------------------------------------------------------------------
    % Simulink-only methods
    %----------------------------------------------------------------------
    methods(Access = protected)
        %------------------------------------------------------------------
        
        function [futureGlobalTrajectory, futureGlobalCoordTrajectory] = getOutputSizeImpl(~)
            % Return size for each output port
            % futureRelativeTrajectory = 1;
            futureGlobalTrajectory = 1;
            futureGlobalCoordTrajectory = 1;
        end
        %------------------------------------------------------------------
        function [futureGlobalTrajectory, futureGlobalCoordTrajectory] = getOutputDataTypeImpl(~)
            % Return data type for each output port            
            % futureRelativeTrajectory = "BusPredictedTrajectories";
            futureGlobalTrajectory = "BusPredictedTrajectories";
            futureGlobalCoordTrajectory = "BusPredictedTrajectories";
        end
        %------------------------------------------------------------------
        function [futureGlobalTrajectory, futureGlobalCoordTrajectory] = isOutputComplexImpl(~)
            % Return true for each output port with complex data
            % futureRelativeTrajectory = false;
            futureGlobalTrajectory = false;
            futureGlobalCoordTrajectory = false;
        end
        %------------------------------------------------------------------
        function [futureGlobalTrajectory, futureGlobalCoordTrajectory] = isOutputFixedSizeImpl(~)
            % Return true for each output port with fixed size
            % futureRelativeTrajectory = true;
            futureGlobalTrajectory = true;
            futureGlobalCoordTrajectory = true;
        end
    end    
end