classdef HelperLCPlannerDefaultData
    % HelperLCPlannerDefaultData specifies the default values required for
    % lane change planner.
    %
    % NOTE: The name of this class and it's functionality may change 
    % without notice in a future release, or the class itself may be 
    % removed.
    %
    
    % Copyright 2021-2022 The MathWorks, Inc.
    properties(Constant)
        % 36 length char used for lane ID and lane boundary ID
        ID = repmat('0', 1, 36);
        MaxMIOs = 10;
        maxTrajectoryPoints = 41;
        maxControlPoints = 48;
        maxTrajectories = 30;
        MaxGaps = 15;
        MaxTargetActors = 30;
        NumFreeSet = 8;
        degree = 5;
    end

    methods(Static)
      % /////////////////////////////////////////////////////////////////
      function out = EgoAndTargetStates()
         K = HelperLCPlannerDefaultData.MaxMIOs;
         out = struct(...
            "NumTargetActors", 0,...
            "TargetGlobalStates", zeros(K, 6),...
            "TargetFrenetStates", zeros(K, 6),...
            "TargetIDs", zeros(K,1),...
            "EgoGlobalState", zeros(1, 6),...
            "EgoFrenetState", zeros(1, 6));
      end

      % //////////////////////////////////////////////////////////////////
      function out = EgoAndTargetRelativeStates()
         K = HelperLCPlannerDefaultData.MaxMIOs;
         out = struct(...
            'NumTargetActors', 0,...
            'TargetRelativeStates', zeros(K, 6),...
            'TargetRelativeFrenetStates', zeros(K, 6),...
            'TargetIDs', zeros(K, 1),...
            'EgoGlobalFrenetState', zeros(1, 6));
      end

      % /////////////////////////////////////////////////////////////////
      function out = MIOInfo()
         K = HelperLCPlannerDefaultData.MaxMIOs;
         T = HelperLCPlannerDefaultData.maxTrajectoryPoints;
         out = struct(...
            "numMIO", 0,...
            "MIO_lane", zeros(K,1),...
            "MIO_vel", zeros(K,1),...
            "isChange", zeros(K,1),...
            "changeidx", 0,...
            "TargetIDs", zeros(K, 1),...
            "Trajectory", zeros(K, T));
      end

      % /////////////////////////////////////////////////////////////////
      function out = MIOFrenetStates()
         K = HelperLCPlannerDefaultData.MaxMIOs;
         out = struct(...
            "NumMIOs", 0,...
            "TargetIds", zeros(1, K),...
            "MIOStates", zeros(K, 6));
      end

      % /////////////////////////////////////////////////////////////////
      function out = GlobalTrajectory()
         T = HelperLCPlannerDefaultData.maxTrajectoryPoints;
         out = struct(...
            "Trajectory", zeros(T, 6),...
            "Times", zeros(T, 1),...
            "NumTrajPoints", 0,...
            "IsValid", false,...
            "IsEvaluated", false,...
            "IsColliding", false,...
            "TargetLane", 0,...
            "DurationTime", 0);
      end

      % /////////////////////////////////////////////////////////////////
      function out = GlobalTrajectories()
         M = HelperLCPlannerDefaultData.maxTrajectories;
         out = struct(...
            "NumTrajectories", 0,...
            "IsNew", false,...
            "OptimalTrajectoryIndex", 0,...
            "Isresample", false, ...
            "GlobalTrajectory",repmat(HelperLCPlannerDefaultData.GlobalTrajectory, M, 1));
      end

      % /////////////////////////////////////////////////////////////////
      function out = PredictedTrajectory()
         T = HelperLCPlannerDefaultData.maxTrajectoryPoints;
         out = struct(...
            "TargetID", uint8(0),...
            "NumPts", uint16(0),...
            "Trajectory", zeros(T, 6));
      end

      % /////////////////////////////////////////////////////////////////
      function out = PredictedTrajectories()
         A = HelperLCPlannerDefaultData.MaxTargetActors;
         out = struct(...
            "NumTrajs", uint8(0),...
            "TargetIDs", zeros(A, 1,'uint8'),...
            "Trajectories", repmat(HelperLCPlannerDefaultData.PredictedTrajectory, A, 1));
      end

      % /////////////////////////////////////////////////////////////////
      function out = RefPointOnPath()
         out = struct(...
            "CurrPoseRr", zeros(1,3),...
            "RefPoseRr", zeros(1,3),...
            "LatOffset", 0,...
            "RefCurvature", 0,...
            "RefCurvatureDer", 0,...
            "RefYawDiff", 0,...
            "RefVelocity", 0,...
            "RefAccel", 0,...
            "RefAngVel", 0);
      end
   
      % /////////////////////////////////////////////////////////////////
      function out = LaneChangeGap()
         out = struct(...
            "idx", 0,...
            "time_local_idx", 0,...
            "local_idx", 0,...
            "lane_idx", 0, ...
            "global_lane_idx", 0, ...
            "time_idx", 0, ...
            "s", 0, ...
            "d", 0, ...
            "l", 0, ...
            "w", 0, ...
            "target_vel", zeros(1, 2), ...
            "vel_range", zeros(3, 2), ...
            "IsValid", true, ...
            "node_cost", 0, ...
            "spatio_cost", 0, ...
            "temporal_cost", 0, ...
            "total_cost", 0);
      end
    
       % /////////////////////////////////////////////////////////////////
      function out = FreeSet()
         G = HelperLCPlannerDefaultData.MaxGaps;
         out = struct(...
            'time_idx', 0, ...
            'num_gaps', 0, ...
            'G_t', repmat(HelperLCPlannerDefaultData.LaneChangeGap, 3, G), ...
            'num_gaps_lane', zeros(1, 3));
      end

       % /////////////////////////////////////////////////////////////////
      function out = LCConnectableSet()
         G = HelperLCPlannerDefaultData.MaxGaps;
         out = struct(...
            'time_idx', 0, ...
            'num_gaps', 0, ...
            'num_gaps_lane', zeros(1, 3), ...
            'num_nodes', 0, ...
            'reachable_mtrx', zeros(G*3, G*3), ...
            'spatio_topology_graph', zeros(2, G*3), ...
            'spatio_topology_global_graph', zeros(2, G*3), ...
            'gaps', repmat(HelperLCPlannerDefaultData.LaneChangeGap, 1, G*3));
      end

      function out = LKConnectableSet()
         G = HelperLCPlannerDefaultData.MaxGaps;
         out = struct(...
            'time_idx', 0, ...
            'current_spatio_set', HelperLCPlannerDefaultData.LCConnectableSet, ...
            'next_spatio_set', HelperLCPlannerDefaultData.LCConnectableSet, ...
            'num_nodes', 0, ...
            'overlap_threshold', 0.2, ...
            'temporal_topology_global_graph', zeros(2, G));
      end

       % /////////////////////////////////////////////////////////////////
      function out = SpatioTemporalSafetySet()
         F = HelperLCPlannerDefaultData.NumFreeSet;
         out = struct(...
                  'F_t', repmat(HelperLCPlannerDefaultData.FreeSet, F, 1), ...
                  'Cc_t', repmat(HelperLCPlannerDefaultData.LCConnectableSet, F, 1), ...
                  'Ck_t', repmat(HelperLCPlannerDefaultData.LKConnectableSet, F, 1));
                    
      end

      % /////////////////////////////////////////////////////////////////
      function out = GraphPlanner()
         G = HelperLCPlannerDefaultData.MaxGaps;
         F = HelperLCPlannerDefaultData.NumFreeSet;
         out = struct(...
                  'Gaps', repmat(HelperLCPlannerDefaultData.LaneChangeGap, 1, G*3*8), ...
                  'adjacency_matrix', zeros(G*3*8, G*3*8), ...
                  'start_node', 0, ...
                  'end_nodes', zeros(1, G*3), ...
                  'optimal_gap_sequence', zeros(1, F), ...
                  'num_total_nodes', 0);
      end

      function out = TrajectoryOptimizer()
         T = HelperLCPlannerDefaultData.maxControlPoints;
         F = HelperLCPlannerDefaultData.NumFreeSet;
         D = HelperLCPlannerDefaultData.degree;
         out = struct(...
                  'NumControlPoints', T, ...
                  'Optimal_S', zeros(F, D+1), ...
                  'Optimal_D', zeros(F, D+1), ...
                  'Target_MIO_State', zeros(1, 6));
      end
    end

end

