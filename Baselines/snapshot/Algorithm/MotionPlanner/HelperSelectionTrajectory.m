classdef HelperSelectionTrajectory<matlab.System
    %HelperMotionPrediction System Object computes future states
    %of the MIOS based on current states using constant velocity model.
    %
    % HelperMotionPrediction System Object uses the current MIO
    % Position to predict the future trajectories of MIO by assuming them
    % to be moving with a constant velocity during the planning time and
    % computing the states accordingly
    %
    % Step function Syntax:function FutureTrajectory = stepImpl(obj,Params,
    % LaneInfo, MIOs). It returns the predicted trajectories of the MIOs,
    % FutureTrajectory respectively based on the information of the planner
    % parameters, Params, global plan points coming from, LaneInfo, and
    % MIOs Frenet state information, MIOs.
    %
    % NOTE: The name of this System Object and it's functionality may
    % change without notice in a future release, or the System Object
    % itself may be removed.
    %
    
    % Copyright 2020-2022 The MathWorks, Inc.
    
    %----------------------------------------------------------------------
    %Private Variables
    properties(Access = private)
        
        %RefPathFrenet holds the object of  referencePathFrenet for a
        %particular Reference Path.
        % RefPathFrenet holds the instance of referencePathFrenet. The
        % RefPathFrenet object is used for transforming the Frenet
        % trajectories to global trajectories.
        RefPathFrenet;
                
        %RefPathPoints is used to store the waypoints for the
        %reference path generated by RefPathFrenet.
        RefPathPoints;

        %PredictedTrajectoryInitStruct defines the predicted trajectory
        % structure that was defined by the Bus object in base workspace.
        % Default = struct
        PredictedTrajectoryInitStruct = HelperLCPlannerDefaultData.PredictedTrajectories;

        % Time Horizon for which the planning has to be done.
        % Default value = 3
        TimeHorizons = 3;
        
        % TimeResolution defines the time interval between.
        % Default = 0.1
        TimeResolution = 0.1;
        
        % Total Number of Target vehicles.
        % Default = 50
        NumTargets = 50;
        NumStep = 0;
        VelocityHorizons = 0;
    end
    
    %----------------------------------------------------------------------
    % Main algorithm
    %----------------------------------------------------------------------
    methods
        function obj = HelperSelectionTrajectory(varargin)
            % Support name-value pair arguments when constructing object
            setProperties(obj, nargin,varargin{:})
            coder.varsize('referencePathPoints');
            
            % Initialize RefPathPoints.
            referencePathPoints = [0 0; 600, 0];
            obj.RefPathPoints = referencePathPoints;
        end
    end
    
    methods(Access = protected)
        %------------------------------------------------------------------
        function setupImpl(obj)
            % setupImpl function performs the one time calculations and
            % Initializations
            % The setupImpl function is used to initialize values or
            % the object to RefPathFrent and compute the maximum
            % of the timeHorizons (if given a range)
            
            % Construct and assign referencePathFrenet object with a
            % default initial path to RefPathFrenet
            obj.RefPathFrenet = referencePathFrenet(obj.RefPathPoints);           
        end
        
        %------------------------------------------------------------------
        function [optimal_a,...
                    optimal_b] = stepImpl(obj, a_valid, b_valid, result, Params,...
                                                    ego_info, num_valid_path, replanningSignal,...
                                                    sdot_T_global, mioTraj, ego_gap, target_gap,...
                                                    mapInfo, safe_idx, actorsprofile, resamplingSignal, Prev_lane_idx)
            obj.TimeHorizons = Params.TimeHorizon;
            obj.TimeResolution = Params.TimeResolution;
            obj.NumStep = (obj.TimeHorizons / obj.TimeResolution) + 1;
            obj.VelocityHorizons = Params.velocityHorizon;
            resamplingSignal = false;

            if sdot_T_global > ego_info(2)
                weight_j    = 1;
                weight_a    = 1;
                weight_k    = 5;
                weight_v    = 3;
                weight_t    = 0.5;
                weight_cs   = 0.1;
                sdot_T      = sdot_T_global;
            else
                weight_j    = 1;
                weight_a    = 1;
                weight_k    = 5;
                weight_v    = 1;
                weight_t    = 3.5;
                weight_cs   = 0.1;
                sdot_T      = sdot_T_global;
            end
            scaleFactor_accel = 10;
            scaleFactor_longitudinal_jerk = 10;
            scaleFactor_lateral_jerk = 100;
            scaleFactor_lateral_jerk2 = 10;
        
            v_max = 100/3.6;
            v_min = 60/3.6;
            a_max = 3.0;
            j_s_max = 2.94;
            j_d_max = 0.9;
            k_max = 0.146;
   
            persistent prev_optimal_a prev_optimal_b prev_optimal_cost
            
            if isempty(prev_optimal_a)
                prev_optimal_a = zeros(6, 1);
                prev_optimal_b = zeros(5, 1);
                prev_optimal_cost = 0;
            end

            if replanningSignal
                if result == false
                    optimal_a = a_valid(:, 1);
                    optimal_b = b_valid(:, 1);
                    return;
                end


                n = 1;
                check_overlap = [b_valid(4, 1:obj.VelocityHorizons) - b_valid(4, 1),...
                                 b_valid(5, 1:obj.VelocityHorizons) - b_valid(5, 1)];

                if ~nnz(check_overlap)
                    optimal_a = a_valid(:, num_valid_path);
                    optimal_b = b_valid(:, num_valid_path);

                else
                    cost = zeros(1, num_valid_path);
                    C_a_vals    = zeros(1, num_valid_path);
                    C_v_vals    = zeros(1, num_valid_path);
                    C_j_s_vals  = zeros(1, num_valid_path);
                    C_j_d_vals  = zeros(1, num_valid_path);
                    C_k_vals    = zeros(1, num_valid_path);
                    C_t_vals    = zeros(1, num_valid_path);
                    for i = 1:length(obj.TimeHorizons)
                        if n > num_valid_path
                            break;
                        end
                        T_idx = ceil(safe_idx(n)/obj.VelocityHorizons);
                        DurationTime = obj.TimeHorizons(T_idx);
                        numTrajPoint = obj.NumStep(T_idx);
                        dt = linspace(0, DurationTime, numTrajPoint);
                        for j = 1:obj.VelocityHorizons
                            % a = [a0 a1 a2 a3 a4 a5]
                            % b = [b0 b1 b2 b3 b4]
                            v_coef  = polyder(b_valid(end:-1:1, n));
                            v_d_coef = polyder(a_valid(end:-1:1, n));

                            a_coef  = polyder(v_coef);
                            a_d_coef = polyder(v_d_coef);

                            j_s_coef  = polyder(a_coef);
                            j_d_coef = polyder(a_d_coef);

                            s_value = polyval(b_valid(end:-1:1, n), dt);
                            d_value = polyval(a_valid(end:-1:1, n), dt);

                            s_dot_value = polyval(v_coef, dt);
                            s_dot_dot_value = polyval(a_coef, dt);

                            j_s_value = polyval(j_s_coef, dt);
                            j_d_value = polyval(j_d_coef, dt);
                            
                            C_v = sum(((sdot_T - s_dot_value) / (v_max-v_min)).^2) / DurationTime;

                            C_a = sum(s_dot_dot_value / (a_max*scaleFactor_accel)).^2 / DurationTime;

                            C_j_s = sum((j_s_value / (j_s_max*scaleFactor_longitudinal_jerk)).^2) / DurationTime;

                            C_j_d = sum((j_d_value / (j_d_max*scaleFactor_lateral_jerk)).^2) / (scaleFactor_lateral_jerk2*DurationTime);

                            K_1 = (2*b_valid(3, n) + 6*b_valid(4, n)*dt + 12*b_valid(5, n)*dt.^2) .*...
                                  (a_valid(2, n) + 2*a_valid(3, n)*dt + 3*a_valid(4, n)*dt.^2 + 4*a_valid(5, n)*dt.^3 + 5*a_valid(6, n)*dt.^4);
    
                            K_2 = (b_valid(2, n) + 2*b_valid(3, n)*dt + 3*b_valid(4, n)*dt.^2 + 4*b_valid(5, n)*dt.^3) .*...
                                  (2*a_valid(3, n) + 6*a_valid(4, n)*dt + 12*a_valid(5, n)*dt.^2 + 20*a_valid(6, n)*dt.^3);
    
                            K_3 = (b_valid(2, n) + 2*b_valid(3, n)*dt + 3*b_valid(4, n)*dt.^2 + 4*b_valid(5, n)*dt.^3).^2  + ...
                                  (a_valid(2, n) + 2*a_valid(3, n)*dt + 3*a_valid(4, n)*dt.^2 + 4*a_valid(5, n)*dt.^3 + 5*a_valid(6, n)*dt.^4).^2;
    
                            C_k = sum(((abs(K_1-K_2) ./ (K_3).^1.5) / k_max).^2) / DurationTime;

                            C_t = helperCalculateTTCFunction(ego_gap, target_gap, mioTraj, dt, s_value, d_value, s_dot_value, DurationTime, mapInfo,...
                                                             actorsprofile);
    
                            cost(n) = (weight_a*C_a + ...
                                weight_v*C_v + ...
                                weight_j*(C_j_d + C_j_s) +...
                                weight_k*C_k + ...
                                weight_t*C_t);

                            C_a_vals(n) = weight_a * C_a;
                            C_v_vals(n) = weight_v * C_v;
                            C_j_s_vals(n) = weight_j * C_j_s;
                            C_j_d_vals(n) = weight_j * C_j_d;
                            C_k_vals(n) = weight_k * C_k;
                            C_t_vals(n) = weight_t * C_t;

                            n = n+1;
                        end
                    end
                    [lowest_value, idx] = min(cost);
                    optimal_a = a_valid(:, idx(1));
                    optimal_b = b_valid(:, idx(1));
                    prev_optimal_a = optimal_a;
                    prev_optimal_b = optimal_b;
                    prev_optimal_cost = lowest_value;
                    
                    % figure('Position',[100, 100, 1600, 900]);
                    % subplot(241)
                    % bar(1:num_valid_path, C_a_vals);
                    % title('C_a for Each Trajectory');
                    % ylabel('Cost Value');
                    % 
                    % subplot(242)
                    % bar(1:num_valid_path, C_v_vals);
                    % title('C_v for Each Trajectory');
                    % ylabel('Cost Value');
                    % 
                    % subplot(243)
                    % bar(1:num_valid_path, C_j_s_vals);
                    % title('C_{sj} for Each Trajectory');
                    % ylabel('Cost Value');
                    % 
                    % subplot(244)
                    % bar(1:num_valid_path, C_j_d_vals);
                    % title('C_{dj} for Each Trajectory');
                    % ylabel('Cost Value');
                    % 
                    % subplot(245)
                    % bar(1:num_valid_path, C_k_vals);
                    % title('C_k for Each Trajectory');
                    % ylabel('Cost Value');
                    % 
                    % subplot(246)
                    % bar(1:num_valid_path, C_t_vals);
                    % title('C_{ttc} for Each Trajectory');
                    % ylabel('Cost Value');
                    % 
                    % subplot(247)
                    % bar(1:num_valid_path, cost);
                    % title('C_{tot} for Each Trajectory');
                    % ylabel('Cost Value');
                    % set(gcf, 'Color','w');
                end 

            elseif (resamplingSignal && ~replanningSignal)
                target_lane = target_gap.lane_idx;
                prev_lane = Prev_lane_idx;
                target_lane_center  = mapInfo.LaneCenters(target_lane);
                prev_lane_center    = mapInfo.LaneCenters(prev_lane);
                ego_lateral = ego_info(4);
                if result == false
                    optimal_a = prev_optimal_a;
                    optimal_b = prev_optimal_b;
                    return;
                end

                n = 1;
                cost = zeros(1, num_valid_path);
                C_a_vals    = zeros(1, num_valid_path);
                C_v_vals    = zeros(1, num_valid_path);
                C_j_s_vals  = zeros(1, num_valid_path);
                C_j_d_vals  = zeros(1, num_valid_path);
                C_k_vals    = zeros(1, num_valid_path);
                C_t_vals    = zeros(1, num_valid_path);
                C_cs_vals   = zeros(1, num_valid_path);

                for i = 1:length(obj.TimeHorizons)
                    if n > num_valid_path
                        break;
                    end
                    T_idx = ceil(safe_idx(n)/obj.VelocityHorizons);
                    DurationTime = obj.TimeHorizons(T_idx);
                    numTrajPoint = obj.NumStep(T_idx);
                    dt = linspace(0, DurationTime, numTrajPoint);
                    for j = 1:obj.VelocityHorizons
                        % a = [a0 a1 a2 a3 a4 a5]
                        % b = [b0 b1 b2 b3 b4]
                        v_coef  = polyder(b_valid(end:-1:1, n));
                        v_d_coef = polyder(a_valid(end:-1:1, n));

                        a_coef  = polyder(v_coef);
                        a_d_coef = polyder(v_d_coef);

                        j_s_coef  = polyder(a_coef);
                        j_d_coef = polyder(a_d_coef);

                        s_value = polyval(b_valid(end:-1:1, n), dt);
                        d_value = polyval(a_valid(end:-1:1, n), dt);

                        s_dot_value = polyval(v_coef, dt);
                        s_dot_dot_value = polyval(a_coef, dt);

                        j_s_value = polyval(j_s_coef, dt);
                        j_d_value = polyval(j_d_coef, dt);
                        
                        C_v = sum(((sdot_T - s_dot_value) / (v_max-v_min)).^2) / DurationTime;

                        C_a = sum(s_dot_dot_value / (a_max*scaleFactor_accel)).^2 / DurationTime;

                        C_j_s = sum((j_s_value / (j_s_max*scaleFactor_longitudinal_jerk)).^2) / DurationTime;

                        C_j_d = sum((j_d_value / (j_d_max*scaleFactor_lateral_jerk)).^2) / (scaleFactor_lateral_jerk2*DurationTime);

                        K_1 = (2*b_valid(3, n) + 6*b_valid(4, n)*dt + 12*b_valid(5, n)*dt.^2) .*...
                              (a_valid(2, n) + 2*a_valid(3, n)*dt + 3*a_valid(4, n)*dt.^2 + 4*a_valid(5, n)*dt.^3 + 5*a_valid(6, n)*dt.^4);

                        K_2 = (b_valid(2, n) + 2*b_valid(3, n)*dt + 3*b_valid(4, n)*dt.^2 + 4*b_valid(5, n)*dt.^3) .*...
                              (2*a_valid(3, n) + 6*a_valid(4, n)*dt + 12*a_valid(5, n)*dt.^2 + 20*a_valid(6, n)*dt.^3);

                        K_3 = (b_valid(2, n) + 2*b_valid(3, n)*dt + 3*b_valid(4, n)*dt.^2 + 4*b_valid(5, n)*dt.^3).^2  + ...
                              (a_valid(2, n) + 2*a_valid(3, n)*dt + 3*a_valid(4, n)*dt.^2 + 4*a_valid(5, n)*dt.^3 + 5*a_valid(6, n)*dt.^4).^2;

                        C_k = sum(((abs(K_1-K_2) ./ (K_3).^1.5) / k_max).^2) / DurationTime;

                        C_t = helperCalculateTTCFunction(ego_gap, target_gap, mioTraj, dt, ...
                                                         s_value, d_value, s_dot_value, ...
                                                         DurationTime, mapInfo, actorsprofile);

                        
                        C_cs = helperCalculateConsistencyFunction(ego_lateral, prev_lane_center, ...
                                                                  target_lane_center);


                        cost(n) = (weight_a* C_a + ...
                                   weight_v* C_v + ...
                                   weight_j*(C_j_d + C_j_s) +...
                                   weight_k* C_k + ...
                                   weight_t* C_t + ...
                                   weight_cs*C_cs);

                        C_a_vals(n)     = weight_a * C_a;
                        C_v_vals(n)     = weight_v * C_v;
                        C_j_s_vals(n)   = weight_j * C_j_s;
                        C_j_d_vals(n)   = weight_j * C_j_d;
                        C_k_vals(n)     = weight_k * C_k;
                        C_t_vals(n)     = weight_t * C_t;
                        C_cs_vals(n)    = weight_cs * C_cs;

                        n = n+1;
                    end
                end
                [lowest_value, idx] = min(cost);
                new_optimal_a = a_valid(:, idx(1));
                new_optimal_b = b_valid(:, idx(1));
            
                if lowest_value < prev_optimal_cost
                    % resample Traj -> replan Traj convert
                    % Revision of Value by subtracting Consistency Cost
                    optimal_a = new_optimal_a;
                    optimal_b = new_optimal_b;
                    prev_optimal_a = optimal_a;
                    prev_optimal_b = optimal_b;
                    prev_optimal_cost = lowest_value - C_cs_vals(idx);
                else
                    optimal_a = prev_optimal_a;
                    optimal_b = prev_optimal_b;
                end
         
            else
                optimal_a = prev_optimal_a;
                optimal_b = prev_optimal_b;
            end
        end
    end
    
    %----------------------------------------------------------------------
    % Common methods
    %----------------------------------------------------------------------
    methods(Access = protected)
        %------------------------------------------------------------------
        function s = saveObjectImpl(obj)
            % save object
            s = saveObjectImpl@matlab.System(obj);
        end
        
        %------------------------------------------------------------------
        function loadObjectImpl(obj,s,wasLocked)
            % load object
            loadObjectImpl@matlab.System(obj,s,wasLocked);
        end
    end
    
    %----------------------------------------------------------------------
    % Simulink-only methods
    %----------------------------------------------------------------------
    methods(Access = protected)
        %------------------------------------------------------------------
        
        function [optimal_a, optimal_b] = getOutputSizeImpl(~)
            % Return size for each output port
            optimal_a = [6, 1];
            optimal_b = [5, 1];
        end
        %------------------------------------------------------------------
        function [optimal_a, optimal_b] = getOutputDataTypeImpl(~)
            % Return data type for each output port            
            optimal_a = "double";
            optimal_b = "double";    
        end
        %------------------------------------------------------------------
        function [optimal_a, optimal_b] = isOutputComplexImpl(~)
            % Return true for each output port with complex data
            optimal_a = false;
            optimal_b = false;
        end
        %------------------------------------------------------------------
        function [optimal_a, optimal_b] = isOutputFixedSizeImpl(~)
            % Return true for each output port with fixed size
            optimal_a = true;
            optimal_b = true;
        end
    end    
end