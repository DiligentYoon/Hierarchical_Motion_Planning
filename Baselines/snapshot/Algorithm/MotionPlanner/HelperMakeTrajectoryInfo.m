classdef HelperMakeTrajectoryInfo < matlab.System    
    %HelperTrajectoryGenerator System Object generates sampled trajectories
    %for the ego vehicle using the sorted terminal states.
    %
    % HelperTrajectoryGenerator system object uses the
    % trajectoryGeneratorFrenet function to generate the trajectories for
    % the ego vehicle at every replan cycle. The default replan cycle is
    % 1sec. The trajectoryGeneratorFrenet object is created and updated
    % based on the information received from the up stream blocks. The
    % global trajectories generated from this system object corresponding
    % to the terminal states are passed to the Validity Checker block.
    %
    % Step Method Syntax:function GlobalTrajectories = stepImpl(obj,
    % SortedTerminalStates, EgoAndTargetStates, LaneInfo, ReplanFlag)
    % returns a structure, GlobalTrajectories containing the trajectories
    % generated corresponding to the terminal states, SortedTerminalStates,
    % ego Frenet state, EgoAndTargetStates, global plan points, LaneInfo,
    % and replan flag, ReplanFlag.
    %
    % For more information see trajectoryGeneratorFrenet
    %
    % NOTE: The name of this System Object and it's functionality may
    % change without notice in a future release, or the System Object
    % itself may be removed.
    %
    
    % Copyright 2020-2022 The MathWorks, Inc.
    
    
    % Private Variables
    properties(Access = private)
        
        %RefPathFrenet holds the instance of referencePathFrenet.
        % The RefPathFrenet holds the instance of referencePathFrenet. This
        % is used to instantiate trajectoryGeneratorFrenet.
        RefPathFrenet;
        
        %PreviousTrajectory holds the generated trajectories in the
        %previous replan cycle.
        % PreviousTrajectory variable is a structure containing trajectory
        % points, and corresponding time samples.
        PreviousTrajectory;
        
        %NumTrajectories holds the number of trajectories generated by the
        %trajectoryGeneratorFrenet.
        % NumTrajectories holds the value of number of trajectories
        % generated by the trajectoryGeneratorFrenet at every replan
        % cycle.
        NumTrajectories;
        
        %RefPathPoints holds the waypoints for the global plan.
        % The RefPathPoints holds the waypoints of the global plan. The
        % default value is [0 0;600 0]
        RefPathPoints;

        HorizonTime = 3;
        HorizonVelocity = 2;
    end
    
    %----------------------------------------------------------------------
    % Main algorithm
    %----------------------------------------------------------------------
    
    methods
        function obj = HelperMakeTrajectoryInfo(varargin)
            % Support name-value pair arguments when constructing object
            setProperties(obj,nargin,varargin{:})
            coder.varsize('referencePathPoints');
            referencePathPoints = [0 0; 600, 0];
            obj.RefPathPoints = referencePathPoints;
        end
    end
    
    methods(Access = protected)
        %------------------------------------------------------------------
        function setupImpl(obj)
            % setupImpl function performs the one time calculations and
            % Initializations.
            % The setupImpl function is used to initialize values or
            % the object to RefPathFrenet, connector, and
            % PreviousTrajectory.
            
            % Initializing the reference path Frenet with a default
            % reference path.
            obj.RefPathFrenet = referencePathFrenet(obj.RefPathPoints);
            
            % Creating a structure for storing the trajectories and the
            % time.
            obj.PreviousTrajectory = HelperLCPlannerDefaultData.GlobalTrajectories().GlobalTrajectory;
            obj.NumTrajectories = 0;
        end
        %------------------------------------------------------------------
        function GlobalTrajectories = stepImpl(obj,...
                optimal_a, optimal_b,...
                a, b,...
                MapInfo,...
                safe_idx, params, resamplingSignal, replanningSignal)
            % stepImpl executes the main algorithm for the
            % HelperTrajectoryGenerator and generates the trajectories at
            % every replan cycle.
            
            % The stepImpl method updates the RefPathFrenet object by
            % checking for the update in waypoints. This method also
            % invokes connect method of trajectoryGeneratorFrenet to
            % generate trajectories corresponding to SortedTerminalStates
            
            % optimal_a, optimal_b  : OptimalTrajectory Coefficients
            % EgoAndTargetStates    : Ego와 주변 차량들에 대한 States
            % RefPointOnPath        : 현재 차량이 따라가는 ReferencePoint
            % MapInfo               : MapInfo
            % ReplanFlag            : result
            persistent prev_GlobalTrajectories
            timeHorizon = params.TimeHorizon;
            velocityHorizon = params.velocityHorizon;
            timestep    = params.TimeResolution;
            Num_total_traj = length(a);
            is_b_equal = all(bsxfun(@eq, b, optimal_b), 1);
            is_a_equal = all(bsxfun(@eq, a, optimal_a), 1);
            optimal_idx = find(is_b_equal & is_a_equal, 1);
            resamplingSignal = false;
            
            if replanningSignal
                if ~isequal(obj.RefPathPoints, MapInfo.GlobalPlanPoints(1:MapInfo.NumGlobalPlanPoints,:))
                    obj.RefPathPoints = MapInfo.GlobalPlanPoints(1:MapInfo.NumGlobalPlanPoints,:);
                    obj.RefPathFrenet.Waypoints = obj.RefPathPoints;
                end

                % Invoke loops and generate trajectories
                obj.PreviousTrajectory = updateTrajectories(obj, a, b, safe_idx, ...
                                                        timeHorizon, velocityHorizon, ...
                                                        timestep, Num_total_traj);

                GlobalTrajectories.NumTrajectories = Num_total_traj;
                GlobalTrajectories.IsNew = true;
                GlobalTrajectories.OptimalTrajectoryIndex = optimal_idx;
                GlobalTrajectories.GlobalTrajectory = obj.PreviousTrajectory;
                prev_GlobalTrajectories = GlobalTrajectories;
            
            elseif (resamplingSignal && ~replanningSignal)
                if isempty(optimal_idx)
                    GlobalTrajectories = prev_GlobalTrajectories;
                    GlobalTrajectories.IsNew = false;
                else
                    if ~isequal(obj.RefPathPoints, MapInfo.GlobalPlanPoints(1:MapInfo.NumGlobalPlanPoints,:))
                        obj.RefPathPoints = MapInfo.GlobalPlanPoints(1:MapInfo.NumGlobalPlanPoints,:);
                        obj.RefPathFrenet.Waypoints = obj.RefPathPoints;
                    end
                    obj.PreviousTrajectory = updateTrajectories(obj, a, b, safe_idx, ...
                                                        timeHorizon, velocityHorizon, ...
                                                        timestep, Num_total_traj);

                    GlobalTrajectories.NumTrajectories = Num_total_traj;
                    GlobalTrajectories.IsNew = true;
                    GlobalTrajectories.OptimalTrajectoryIndex = optimal_idx;
                    GlobalTrajectories.GlobalTrajectory = obj.PreviousTrajectory;
                    prev_GlobalTrajectories = GlobalTrajectories;
                end

            else
                GlobalTrajectories = prev_GlobalTrajectories;
                GlobalTrajectories.IsNew = false;
            end
        end

        function PrevTraj = updateTrajectories(objLocal, aLocal, bLocal, safeIdx, ...
                                               tHorizon, vHorizon, dt, N_traj)
            % 외부 변수 참조 없이 함수 입력값/objLocal로만 처리
            newTraj = objLocal.PreviousTrajectory;
            
            for i = 1:N_traj
                timeidx = ceil(i / vHorizon);
                timeVec = 0 : dt : tHorizon(timeidx);
    
                
                s_t = bLocal(end:-1:1, i)';  % [b0, b1, b2, ...] 순서
                d_t = aLocal(end:-1:1, i)';
    
                
                s_v = polyder(s_t);
                d_v = polyder(d_t);
                s_a = polyder(s_v);
                d_a = polyder(d_v);
    
                s_value    = polyval(s_t, timeVec);
                s_v_value  = polyval(s_v, timeVec);
                s_a_value  = polyval(s_a, timeVec);
                d_value    = polyval(d_t, timeVec);
                d_v_value  = polyval(d_v, timeVec);
                d_a_value  = polyval(d_a, timeVec);
    
                frenetTraj = [s_value', s_v_value', s_a_value', ...
                              d_value', d_v_value', d_a_value'];

                globalTraj = frenet2global(objLocal.RefPathFrenet, frenetTraj, ...
                                           [d_v_value', d_a_value', false*ones(length(timeVec),1)]);
    
                % Trajectory 정보 업데이트
                numTrajPoints = length(timeVec);
                newTraj(i).Times(1:numTrajPoints)           = timeVec;
                newTraj(i).Trajectory(1:numTrajPoints,:)    = globalTraj;
                newTraj(i).NumTrajPoints                    = numTrajPoints;
                newTraj(i).DurationTime                     = timeidx;
    
                % 안전 인덱스인지에 따라 Flag 설정
                if ismember(i, safeIdx)
                    newTraj(i).IsValid      = true;
                    newTraj(i).IsEvaluated  = true;
                    newTraj(i).IsColliding  = false;
                else
                    newTraj(i).IsValid      = false;
                    newTraj(i).IsEvaluated  = false;
                    newTraj(i).IsColliding  = true;
                end
            end
            PrevTraj = newTraj;
        end
    end
    
    %----------------------------------------------------------------------
    % Common methods
    %----------------------------------------------------------------------
    methods(Access = protected)
        %------------------------------------------------------------------
        function s = saveObjectImpl(obj)
            % save object
            s = saveObjectImpl@matlab.System(obj);
        end
        
        %------------------------------------------------------------------
        function loadObjectImpl(obj,s,wasLocked)
            % load object
            loadObjectImpl@matlab.System(obj,s,wasLocked);
        end
    end
    
    %----------------------------------------------------------------------
    % Simulink-only methods
    %----------------------------------------------------------------------
    methods(Access = protected)
        %------------------------------------------------------------------
        function GlobalTraj=getOutputSizeImpl(~)
            % Return size for each output port
            GlobalTraj=1;
        end
        
        %------------------------------------------------------------------
        function Trajectory= getOutputDataTypeImpl(~)
            % Return data type for each output port
            Trajectory="BusGlobalTrajectories";
            
        end
        
        %------------------------------------------------------------------
        function Trajectory= isOutputComplexImpl(~)
            % Return true for each output port with complex data
            Trajectory= false;
    
        end
        
        %------------------------------------------------------------------
        function Trajectory= isOutputFixedSizeImpl(~)
            % Return true for each output port with fixed size
            Trajectory= true;
        end        
    end    
end